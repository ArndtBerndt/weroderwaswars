<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kommissar ermittelt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .character-button {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .character-button.selected {
            border-color: #3b82f6; /* Blue border when selected */
            transform: scale(1.05);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chat-bubble {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            word-wrap: break-word;
        }
        .chat-bubble.user {
            background-color: #3b82f6; /* Blue for user */
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        .chat-bubble.ai {
            background-color: #e5e7eb; /* Gray for AI */
            color: #1f2937; /* Dark gray text */
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        /* Simple spinner for modal */
        .modal-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #3b82f6; /* Blue spinner */
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Hide scrollbar for chat log, but allow scrolling */
         #chat-log {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #chat-log::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        /* Styles for the custom confirmation modal */
        #confirm-accusation-modal {
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent backdrop */
        }
        /* Styles for Protocol Display */
        #protocol-display {
            background-color: #f8f8f8; /* Lighter background */
            border: 1px solid #d1d5db; /* Gray border */
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Inter', sans-serif; /* Use standard font */
            font-size: 0.875rem; /* Slightly smaller font */
            line-height: 1.5;
        }
        #protocol-display h3 {
            font-weight: 700; /* Bolder heading */
            margin-bottom: 12px;
            font-size: 1rem;
            color: #1f2937; /* Darker heading */
        }
         #protocol-display ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 10px;
         }
         #protocol-display li {
            margin-bottom: 6px;
            color: #4b5563; /* Medium gray text */
         }
         #protocol-display strong {
             font-weight: 600; /* Semi-bold */
             color: #111827; /* Slightly darker text for emphasis */
         }
         #protocol-display .protocol-section {
             margin-bottom: 15px;
         }
         #protocol-display hr {
             border-top: 1px dashed #d1d5db;
             margin: 15px 0;
         }
         #protocol-display small {
             font-size: 0.75rem;
             color: #6b7280;
         }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div id="api-key-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full">
            <div id="api-key-content">
                <h2 class="text-xl font-bold mb-4 text-gray-800">Gemini API Schl√ºssel ben√∂tigt</h2>
                <p class="text-gray-600 mb-4">Bitte gib deinen Gemini API Schl√ºssel ein, um das Spiel zu starten. Du kannst einen Schl√ºssel auf <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-500 hover:underline">Google AI Studio</a> erhalten.</p>
                <input type="password" id="api-key-input" class="w-full px-3 py-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Dein API Schl√ºssel">
                <button id="submit-api-key" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Spiel starten</button>
                <p id="api-key-error" class="text-red-500 text-sm mt-2 hidden">Fehler: Bitte gib einen g√ºltigen API Schl√ºssel ein.</p>
            </div>
            <div id="modal-loading-indicator" class="hidden flex flex-col items-center justify-center">
                 <div class="modal-spinner mb-4"></div>
                 <p class="text-gray-700">Generiere Fall...</p>
            </div>
        </div>
    </div>

    <div id="confirm-accusation-modal" class="hidden fixed inset-0 items-center justify-center z-50 p-4">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-lg font-semibold mb-4 text-gray-800">Beschuldigung best√§tigen</h3>
            <p class="text-gray-600 mb-6">Bist du sicher, dass du <strong id="confirm-accusation-name" class="text-gray-900">...</strong> beschuldigen m√∂chtest?</p>
            <div class="flex justify-end gap-3">
                <button id="cancel-accusation-button" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-md transition duration-300">Abbrechen</button>
                <button id="confirm-accusation-button" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md transition duration-300">Beschuldigen</button>
            </div>
        </div>
    </div>


    <div id="game-container" class="container mx-auto bg-white p-6 rounded-lg shadow-lg max-w-4xl hidden">
         <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-gray-800">Kommissar ermittelt</h1>

        <div id="initial-briefing" class="mb-6 p-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 rounded-md shadow">
            <p><strong id="boss-name">Chef:</strong> <span id="boss-emoji"></span> <span id="briefing-text">Warte auf das Briefing...</span></p>
        </div>

        <div id="protocol-display" class="hidden">
            {/* Protocol content will be inserted here by JS */}
        </div>

        <div class="mb-6 mt-6">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">Personen ausw√§hlen:</h2>
            
            <div id="characters" class="grid grid-cols-3 md:grid-cols-6 gap-3 sm:gap-4">
                {/* Character buttons will be inserted here */}
            </div>
             <p class="text-sm text-gray-500 mt-2">Klicke auf eine Person, um sie zu befragen oder zu beschuldigen.</p>
        </div>

        <div id="interaction-area" class="mb-6 hidden">
             <h2 class="text-xl font-semibold mb-3 text-gray-700">Interaktion mit <span id="selected-character-name" class="font-bold">...</span>:</h2>
            <div id="chat-log" class="h-64 overflow-y-auto border border-gray-300 rounded-md p-4 mb-4 bg-gray-50">
                {/* Chat messages will appear here */}
            </div>
            <div class="flex gap-2">
                <input type="text" id="player-input" class="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Deine Frage eingeben...">
                <button id="send-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Fragen</button>
                <button id="accuse-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 hidden">Beschuldigen</button>
            </div>
             <p id="interaction-error" class="text-red-500 text-sm mt-2 hidden"></p>
        </div>

        <div id="win-lose-message" class="mt-6 p-4 rounded-md shadow text-center font-bold text-lg hidden">
            {/* Win/Lose message appears here */}
        </div>
    </div>

    <script>
        // --- Configuration ---
        const API_KEY_MODAL = document.getElementById('api-key-modal');
        const API_KEY_CONTENT = document.getElementById('api-key-content');
        const MODAL_LOADING_INDICATOR = document.getElementById('modal-loading-indicator');
        const API_KEY_INPUT = document.getElementById('api-key-input');
        const SUBMIT_API_KEY_BUTTON = document.getElementById('submit-api-key');
        const API_KEY_ERROR = document.getElementById('api-key-error');
        const GAME_CONTAINER = document.getElementById('game-container');
        const BOSS_NAME_EL = document.getElementById('boss-name');
        const BOSS_EMOJI_EL = document.getElementById('boss-emoji');
        const BRIEFING_TEXT_EL = document.getElementById('briefing-text');
        const CHARACTERS_DIV = document.getElementById('characters');
        const INTERACTION_AREA = document.getElementById('interaction-area');
        const SELECTED_CHAR_NAME_EL = document.getElementById('selected-character-name');
        const CHAT_LOG = document.getElementById('chat-log');
        const PLAYER_INPUT = document.getElementById('player-input');
        const SEND_BUTTON = document.getElementById('send-button');
        const ACCUSE_BUTTON = document.getElementById('accuse-button');
        const WIN_LOSE_MESSAGE = document.getElementById('win-lose-message');
        const INTERACTION_ERROR = document.getElementById('interaction-error');
        const CONFIRM_ACCUSATION_MODAL = document.getElementById('confirm-accusation-modal');
        const CONFIRM_ACCUSATION_NAME = document.getElementById('confirm-accusation-name');
        const CANCEL_ACCUSATION_BUTTON = document.getElementById('cancel-accusation-button');
        const CONFIRM_ACCUSATION_BUTTON = document.getElementById('confirm-accusation-button');
        const PROTOCOL_DISPLAY = document.getElementById('protocol-display');


        let apiKey = '';
        let gameData = null;
        let selectedCharacterId = null;
        let conversationHistory = {};
        let gameEnded = false;

        // --- Gemini API Interaction ---
        const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=';

        async function callGeminiAPI(prompt, history = [], generationConfig = null) {
            INTERACTION_ERROR.classList.add('hidden');
            try {
                const requestBody = {
                    contents: [...history, { role: 'user', parts: [{ text: prompt }] }],
                };
                if (generationConfig) {
                    requestBody.generationConfig = generationConfig;
                }

                const response = await fetch(`${API_URL}${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify(requestBody),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('API Error Response:', errorData);
                    const message = errorData?.error?.message || '';
                    if (message.includes('API key not valid') || message.includes('API_KEY_INVALID')) {
                         throw new Error('API key not valid');
                    }
                    throw new Error(`API Fehler: ${response.status} ${response.statusText}. Details: ${message}`);
                }

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]) {
                     console.error('Invalid API response structure (no candidates):', data);
                     throw new Error('Unerwartete API Antwortstruktur (keine Kandidaten).');
                }
                 const candidate = data.candidates[0];
                 if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                     console.error('API call finished due to:', candidate.finishReason, candidate.safetyRatings);
                     let reasonText = candidate.finishReason;
                     if (candidate.finishReason === 'SAFETY') reasonText = 'Sicherheitseinstellungen';
                     else if (candidate.finishReason === 'RECITATION') reasonText = 'Rezitieren von Inhalten';
                     else if (candidate.finishReason === 'OTHER') reasonText = 'Unbekannter Grund';
                     throw new Error(`API Anfrage blockiert oder fehlerhaft (Grund: ${reasonText}).`);
                 }
                 if (!candidate.content || !candidate.content.parts) {
                     console.warn('API response candidate has no content parts:', candidate);
                      if(candidate.finishReason === 'SAFETY') return "(Antwort aufgrund von Sicherheitseinstellungen blockiert)";
                     if (candidate.finishReason === 'STOP' || candidate.finishReason === 'MAX_TOKENS') return "";
                     throw new Error('API Antwort enth√§lt keine Inhaltsteile trotz erfolgreichem Abschluss.');
                 }

                 let textResult = '';
                 if (Array.isArray(candidate.content.parts)) {
                    textResult = candidate.content.parts.map(part => part.text).join('');
                 }
                textResult = textResult.replace(/```json\n?|\n?```/g, '').trim();
                return textResult;

            } catch (error) {
                console.error('Fehler bei der Kommunikation mit der Gemini API:', error);
                if (error.message === 'API key not valid') {
                    showApiKeyError('Ung√ºltiger API Schl√ºssel. Bitte √ºberpr√ºfe ihn.');
                    API_KEY_MODAL.style.display = 'flex';
                    MODAL_LOADING_INDICATOR.classList.add('hidden');
                    API_KEY_CONTENT.classList.remove('hidden');
                    API_KEY_INPUT.disabled = false;
                    SUBMIT_API_KEY_BUTTON.disabled = false;
                    GAME_CONTAINER.classList.add('hidden');
                } else {
                     INTERACTION_ERROR.textContent = `API Kommunikationsfehler: ${error.message}`;
                     INTERACTION_ERROR.classList.remove('hidden');
                }
                return null;
            }
        }

        // --- Game Logic ---

        function showApiKeyError(message) {
             API_KEY_ERROR.textContent = message;
             API_KEY_ERROR.classList.remove('hidden');
        }

        function hideApiKeyError() {
            API_KEY_ERROR.classList.add('hidden');
        }

        async function generatePlot() {
            // --- UPDATED PLOT PROMPT for 5 Suspects ---
            const plotPrompt = `
Erstelle einen Kriminalfall f√ºr ein Text-Detektivspiel auf Deutsch. Der Spieler ist ein Kommissar.
Generiere **f√ºnf** kreative und unterschiedliche Verd√§chtige.

**Hauptanweisung:** Generiere die JSON-Felder **direkt**. Stelle sicher, dass alle generierten Details (Alibis, Wissen, Motive, Hinweise, Fakten) **logisch konsistent** zueinander und zur Fallbeschreibung passen. Ber√ºcksichtige den **Tatzeitpunkt** bei Alibis und Wissen. Alibis m√ºssen **spezifische Zeitangaben** und ggf. Interaktionen mit anderen Verd√§chtigen enthalten.

Gib die Ausgabe NUR als JSON-Objekt zur√ºck. Keine Markdown-Formatierung um das JSON.

**Wichtige Anweisungen f√ºr den Fall:**
1.  **Gleiche Verdachtslage:** Das Ziel ist ein Fall, bei dem **alle f√ºnf Verd√§chtigen gleicherma√üen plausibel** erscheinen. Es darf **keinen offensichtlichen Hauptverd√§chtigen** geben.
2.  **Motive f√ºr Alle:** Jeder der f√ºnf Verd√§chtigen **muss** ein **starkes, plausibles Motiv** haben.
3.  **Verdachtsgrund f√ºr Alle:** Jeder Verd√§chtige **muss** einen kurzen **'verdachts_grund'** haben (z.B. Motiv, Gelegenheit, widerspr√ºchliche erste Aussage).
4.  **Beziehungen:** Die Verd√§chtigen sollen sich **teilweise untereinander kennen** (manche gut, manche kaum). Beschreibe diese Beziehungen kurz in 'rolle' oder 'wissen'.
5.  **Hinweise & Fakten:**
    * **'entscheidende_hinweise' (genau 2-3 St√ºck):** Fakten (Aktionen, Zeiten, Orte, Aussagen), die (in Kombination) einen **Widerspruch im Alibi/Wissen des T√§ters** aufdecken. D√ºrfen **NICHT** der Polizei bekannt sein und m√ºssen von Verd√§chtigen stammen. **Keine Hinweise auf physische Beweisst√ºcke**. M√ºssen durch Gespr√§che √ºberpr√ºfbar sein. Format: "Fakt (√ºberpr√ºfbar) / Bekannt von: [Name(n) Verd√§chtige(r)] / (Widerspricht: [Alibi/Aussage von T√§ter])"
    * **'neutrale_fakten' (ca. 40 St√ºck):** Fakten/Beobachtungen. Sollen **mehrdeutig sein und potenziell alle Verd√§chtigen gleicherma√üen belasten**, ohne einen klar zu favorisieren oder auszuschlie√üen. Einige davon sollen **verifizierbare Zeit-/Ortsangaben** enthalten und der Polizei bekannt sein. Format: "Fakt / Bekannt von: [Name(n) oder Polizei oder Mehrere Namen]" (Erlaube explizit mehrere Quellen)
    * Stelle sicher, dass die Hinweise und Fakten so verteilt sind, dass **jeder Verd√§chtige mit einigen Fakten oder Hinweisen in Verbindung gebracht wird**.
6.  **Individuelle Perspektiven:** Wenn mehrere Verd√§chtige dasselbe Ereignis miterlebt haben (was sich aus den Fakten ergeben kann), beschreibe im Feld 'wissen' ihre **individuelle Wahrnehmung oder Interpretation** davon.
7.  **Realismus & Subtilit√§t:** Der Fall soll realistisch sein. Die L√∂sung ergibt sich aus **Widerspr√ºchen**, nicht aus einem einzelnen Beweis. Hinweise sollen subtil sein.
8.  **T√§ter:** W√§hle EINEN der f√ºnf generierten Verd√§chtigen als T√§ter aus. Motivation muss passen. Alibi muss L√ºcken/Widerspr√ºche haben.
9.  **Polizist:** Kennt T√§ter nicht, gibt nur die ihm bekannten (mehrdeutigen, teils verifizierbaren) Fakten absolut neutral weiter.

JSON-Struktur:
{
  "fallbeschreibung": "Kurze Beschreibung des Falls.",
  "tatort": "Ein spezifischer Ort in M√ºnchen (z.B. Englischer Garten, Bereich der TUM/LMU, eine Bar wie 'Kaffee Kosmos', Ma√ümannwohnheim, etc.).",
  "zeitpunkt": "Zeitpunkt des Geschehens.",
  "opfer": { "name": "Generiere einen kreativen, ungew√∂hnlichen Namen f√ºr das Opfer", "beschreibung": "..." },
  "boss": { "name": "Chef Inspektor Tschiggerillo", "emoji": "üë®‚Äç‚úàÔ∏è", "briefing": "..." },
  "polizist": { "id": "polizist_chris", "name": "Polizist Chris", "emoji": "üëÆ‚Äç‚ôÇÔ∏è", "rolle": "..." },
  "verdaechtige": [ // Genau 5 Verd√§chtige generieren
    {
      "id": "char1",
      "name": "Generiere kreativen Vor- und Nachnamen",
      "emoji": "Generiere passendes Emoji",
      "rolle": "Generiere Rolle, Beziehung zu Opfer/anderen, ggf. wichtige Eigenschaft.",
      "motiv": "Generiere starkes, plausibles Motiv.",
      "verdachts_grund": "Generiere kurzen Grund, warum verd√§chtig.",
      "alibi": "Generiere spezifisches Alibi (Zeiten/Interaktionen, L√ºcken wenn T√§ter).",
      "wissen": "Generiere spezifisches Wissen/Geheimnisse (ggf. individuelle Perspektive auf Ereignisse)."
    },
    { "id": "char2", "name": "...", "emoji": "...", "rolle": "...", "motiv": "...", "verdachts_grund": "...", "alibi": "...", "wissen": "..." },
    { "id": "char3", "name": "...", "emoji": "...", "rolle": "...", "motiv": "...", "verdachts_grund": "...", "alibi": "...", "wissen": "..." },
    { "id": "char4", "name": "...", "emoji": "...", "rolle": "...", "motiv": "...", "verdachts_grund": "...", "alibi": "...", "wissen": "..." },
    { "id": "char5", "name": "...", "emoji": "...", "rolle": "...", "motiv": "...", "verdachts_grund": "...", "alibi": "...", "wissen": "..." }
  ],
  "taeter_id": "...", // Eine der IDs: 'char1', 'char2', 'char3', 'char4', 'char5'
  "entscheidende_hinweise": [
    "Fakt (√ºberpr√ºfbar) / Bekannt von: [NUR Name(n) Verd√§chtige(r), KEINE Polizei!] / (Widerspricht: [Alibi/Aussage von T√§ter])",
    // ... (2-3 Eintr√§ge)
  ],
  "neutrale_fakten": [
      "Fakt / Bekannt von: [Name(n) oder Polizei oder Mehrere Namen]", // Explizit mehrere erlaubt
      // ... (ca. 40 Eintr√§ge) // Angepasste Anzahl
  ],
  "loesung_erklaerung": "Erkl√§rung, welcher Widerspruch den T√§ter entlarvt."
}

Stelle sicher, dass das JSON vollst√§ndig und korrekt formatiert ist und alle Felder logisch konsistent sind.
`;
            // --- END OF UPDATED PLOT PROMPT ---


            let attempts = 0;
            const maxAttempts = 3;
            let rawResponse = null;
            gameData = null;
            // Keep token limit generous for 5 suspects + potentially more facts
            const plotGenerationConfig = { maxOutputTokens: 4096, temperature: 0.75 };

            while (attempts < maxAttempts && !gameData) {
                attempts++;
                console.log(`Plot generation attempt ${attempts}...`);
                rawResponse = await callGeminiAPI(plotPrompt, [], plotGenerationConfig);

                if (rawResponse !== null) {
                    try {
                        if (rawResponse.trim().startsWith('{') && rawResponse.trim().endsWith('}')) {
                            gameData = JSON.parse(rawResponse);
                            const validIds = ['char1', 'char2', 'char3', 'char4', 'char5']; // Adjusted IDs for 5 suspects
                            // Perform validation checks for 5 suspects
                            if (gameData &&
                                gameData.verdaechtige && gameData.verdaechtige.length === 5 && // Check for 5 suspects
                                gameData.verdaechtige.every(v => validIds.includes(v.id)) && // Check if all IDs match schema
                                gameData.taeter_id && validIds.includes(gameData.taeter_id) && // Check if taeter_id is one of the generated IDs
                                gameData.boss && gameData.polizist &&
                                gameData.entscheidende_hinweise && Array.isArray(gameData.entscheidende_hinweise) &&
                                gameData.neutrale_fakten && Array.isArray(gameData.neutrale_fakten) &&
                                gameData.loesung_erklaerung &&
                                gameData.verdaechtige.every(v => v.name && v.emoji && v.rolle && v.motiv && v.verdachts_grund && v.alibi && v.wissen)
                               )
                            {
                                let policeIsSourceOfDecisive = false;
                                gameData.entscheidende_hinweise.forEach(hint => {
                                    if (/\/\s*Bekannt von:.*polizei/i.test(hint)) {
                                        policeIsSourceOfDecisive = true;
                                        console.warn("Validation Warning: Polizei ist als Quelle f√ºr entscheidenden Hinweis angegeben:", hint);
                                    }
                                });
                                if(policeIsSourceOfDecisive) {
                                     console.error("Validation Failed: Polizei darf KEINE Quelle f√ºr entscheidende Hinweise sein.");
                                     gameData = null;
                                     continue;
                                }

                                console.log("Plot generated and validated successfully.");
                                console.log("Debug - Entscheidende Hinweise:", gameData.entscheidende_hinweise);
                                console.log("Debug - Neutrale Fakten:", gameData.neutrale_fakten);

                                break; // Exit loop on success
                            } else {
                                console.error("Generated JSON is invalid, incomplete, or failed validation:", gameData);
                                gameData = null;
                            }
                        } else {
                             console.error(`Raw response on attempt ${attempts} does not look like complete JSON.`);
                             gameData = null;
                        }
                    } catch (e) {
                        console.error(`Error parsing JSON on attempt ${attempts}:`, e);
                        console.error("Raw response was:", rawResponse);
                        gameData = null;
                    }
                } else {
                     break;
                }
                 if (attempts < maxAttempts && !gameData) {
                     await new Promise(resolve => setTimeout(resolve, 1500));
                 }
            }

            if (!gameData) {
                console.error("Failed to generate a valid plot after multiple attempts.");
                return false;
            }
            return true;
        }


        function displayCharacters() {
            CHARACTERS_DIV.innerHTML = '';
            conversationHistory = {};
            // Display 5 suspects
            gameData.verdaechtige.forEach(char => {
                addCharacterButton(char);
                conversationHistory[char.id] = [];
            });
            // Display police officer
            addCharacterButton(gameData.polizist);
            conversationHistory[gameData.polizist.id] = [];
        }


        function addCharacterButton(char) {
             const button = document.createElement('button');
             // Adjusted classes for 6 items
             button.classList.add('character-button', 'flex', 'flex-col', 'items-center', 'p-2', 'sm:p-3', 'bg-gray-200', 'rounded-lg', 'hover:bg-gray-300', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-400');
             button.dataset.charId = char.id;
             const emojiSpan = document.createElement('span');
             emojiSpan.classList.add('text-3xl', 'sm:text-4xl', 'mb-1', 'sm:mb-2');
             emojiSpan.textContent = char.emoji;
             const nameSpan = document.createElement('span');
             nameSpan.classList.add('text-xs', 'sm:text-sm', 'font-semibold', 'text-center', 'text-gray-700');
             nameSpan.textContent = char.name;
             button.appendChild(emojiSpan);
             button.appendChild(nameSpan);
             button.addEventListener('click', () => selectCharacter(char.id));
             CHARACTERS_DIV.appendChild(button);
        }

        function selectCharacter(charId) {
            if (gameEnded || !gameData) return;
            selectedCharacterId = charId;
            const character = findCharacterById(charId);
            if (!character) return;
            document.querySelectorAll('.character-button').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.charId === charId) {
                    btn.classList.add('selected');
                }
            });
            SELECTED_CHAR_NAME_EL.textContent = character.name;
            INTERACTION_AREA.classList.remove('hidden');
            const isSuspect = gameData.verdaechtige.some(v => v.id === charId);
            if (isSuspect) {
                ACCUSE_BUTTON.classList.remove('hidden');
                ACCUSE_BUTTON.disabled = false;
                ACCUSE_BUTTON.onclick = () => {
                     showAccusationConfirmation(charId);
                };
            } else {
                ACCUSE_BUTTON.classList.add('hidden');
                ACCUSE_BUTTON.onclick = null;
            }
            loadConversation(charId);
            PLAYER_INPUT.focus();
        }


        function findCharacterById(charId) {
            if (!gameData) return null;
            if (charId === gameData.polizist?.id) {
                return gameData.polizist;
            }
            // Find suspect by generated ID (char1, char2, etc.)
            const suspect = gameData.verdaechtige?.find(v => v.id === charId);
             if (suspect) return suspect;
             console.warn(`Character ID "${charId}" not found among generated IDs or police.`)
             return null;
        }


        function addChatMessage(sender, message, type) {
            const bubble = document.createElement('div');
            bubble.classList.add('chat-bubble', type);
            const senderSpan = document.createElement('strong');
            if (type === 'ai') {
                 senderSpan.textContent = `${sender}: `;
                 bubble.appendChild(senderSpan);
            }
            const messageSpan = document.createElement('span');
            messageSpan.innerText = message || "";
            bubble.appendChild(messageSpan);
            CHAT_LOG.appendChild(bubble);
            CHAT_LOG.scrollTop = CHAT_LOG.scrollHeight;
        }

         function loadConversation(charId) {
            CHAT_LOG.innerHTML = '';
            const history = conversationHistory[charId] || [];
            history.forEach(entry => {
                const message = entry.parts?.[0]?.text;
                if (message !== undefined) {
                    const type = entry.role === 'user' ? 'user' : 'ai';
                    const character = findCharacterById(charId);
                    const senderName = type === 'ai' ? (character?.name || 'System') : 'Du';
                    addChatMessage(senderName, message, type);
                }
            });
        }

        async function handlePlayerInput() {
            if (gameEnded || !selectedCharacterId || !gameData) return;
            const question = PLAYER_INPUT.value.trim();
            if (!question) return;
            const character = findCharacterById(selectedCharacterId);
            if (!character) return;
            addChatMessage('Du', question, 'user');
            PLAYER_INPUT.value = '';
            SEND_BUTTON.disabled = true;
            ACCUSE_BUTTON.disabled = true;
             const currentUserHistory = conversationHistory[selectedCharacterId] || [];
             currentUserHistory.push({ role: 'user', parts: [{ text: question }] });

             const policeKnownFacts = (gameData.neutrale_fakten || []).filter(fact =>
                 /\/\s*Bekannt von:.*polizei/i.test(fact)
             );
             const policeKnownFactsList = policeKnownFacts.join('; ');

             let contextClues = "";
             if (selectedCharacterId === gameData.polizist.id) {
                  contextClues = `Bekannte neutrale Fakten (die die Polizei kennt): ${policeKnownFactsList}`;
             } else {
                  const allCluesAndFacts = [
                     ...(gameData.entscheidende_hinweise || []),
                     ...(gameData.neutrale_fakten || [])
                  ];
                  contextClues = `Bekannte Hinweise/Fakten: ${allCluesAndFacts.join('; ')}`;
             }

            let plotSummary = `
Kriminalfall: ${gameData.fallbeschreibung}
Tatort: ${gameData.tatort}
Zeitpunkt: ${gameData.zeitpunkt}
${gameData.opfer ? `Opfer: ${gameData.opfer.name} (${gameData.opfer.beschreibung})` : ''}
Verd√§chtige: ${gameData.verdaechtige.map(v => `${v.name} (${v.rolle})`).join(', ')}
Polizist vor Ort: ${gameData.polizist.name}
${contextClues}
`;
            let characterInfo = `
Du sprichst gerade mit ${character.name} (${character.emoji}).
Deine generierte Rolle/Beschreibung in diesem Fall: ${character.rolle}.
Dein generiertes Motiv in diesem Fall: ${character.motiv || 'Unbekannt'}.
Dein generiertes Alibi in diesem Fall: ${character.alibi || 'Unbekannt'}.
Dein generiertes spezifisches Wissen in diesem Fall: ${character.wissen || 'Nichts Besonderes'}.
Dein Grund f√ºr Verdacht (intern generiert): ${character.verdachts_grund || 'Unbekannt'}.
`;

            let baseInstructions = '';
            const otherSuspects = gameData.verdaechtige.filter(v => v.id !== selectedCharacterId);
            const otherSuspectNames = otherSuspects.map(v => v.name).join(', ');
             const contradictingClues = (gameData.entscheidende_hinweise || []);


            if (selectedCharacterId === gameData.taeter_id) {
                const innocentSuspects = gameData.verdaechtige.filter(v => v.id !== gameData.taeter_id);
                const innocentSuspectNames = innocentSuspects.map(v => v.name).join(', ');
                 baseInstructions = `Du bist der T√§ter in diesem Fall. Dein Ziel ist es, unentdeckt zu bleiben. Antworte auf Fragen so, dass du unschuldig wirkst. Lenke Verdacht geschickt ab, l√ºge wenn n√∂tig √ºber dein Alibi oder Wissen, aber vermeide offensichtliche Widerspr√ºche zu bekannten Fakten oder den Hinweisen, die dich belasten k√∂nnten (${contradictingClues.join('; ')}), falls du darauf angesprochen wirst. **Suche aktiv nach Gelegenheiten, um Beobachtungen oder Verd√§chtigungen √ºber andere unschuldige Verd√§chtige (${innocentSuspectNames}) zu √§u√üern, um von dir abzulenken, eventuell unter Verwendung der neutralen Fakten.** Betone deine pers√∂nliche Sichtweise oder Erinnerung, wenn du √ºber Ereignisse sprichst. Sei vielleicht nerv√∂s oder √ºberm√§√üig ruhig.`;
            } else if (gameData.verdaechtige.some(v => v.id === selectedCharacterId)) {
                 baseInstructions = `Du bist unschuldig in diesem Fall, aber vielleicht nerv√∂s oder hast etwas anderes zu verbergen (basierend auf deinem 'Wissen'). Antworte ehrlich auf Fragen bez√ºglich deines tats√§chlichen Wissens und Alibis. Kommentiere Hinweise/Fakten nur, wenn du direkt danach gefragt wirst oder sie dein Alibi st√ºtzen/widerlegen. **Suche aktiv nach Gelegenheiten, um Beobachtungen oder Verd√§chtigungen √ºber andere Verd√§chtige (${otherSuspectNames}) zu √§u√üern, besonders wenn deren Aussagen deinem Wissen widersprechen, aber erfinde nichts.** Betone deine pers√∂nliche Sichtweise oder Erinnerung, wenn du √ºber Ereignisse sprichst. Gib nicht mehr preis als n√∂tig.`;
            } else if (selectedCharacterId === gameData.polizist.id) {
                 baseInstructions = `Du bist ${gameData.polizist.name}. Du hilfst dem Kommissar NUR mit objektiven Fakten, die der Polizei bekannt sind (diese stammen aus der Liste der 'neutrale_fakten', die mit 'Bekannt von: Polizei' markiert sind). Berichte diese Fakten **absolut neutral und ohne jede Interpretation oder Andeutung**, wer verd√§chtig sein k√∂nnte. Du wei√üt NICHT, wer der T√§ter ist und kennst die entscheidenden Hinweise nicht. √Ñu√üere KEINE Vermutungen. Wenn du nach einem spezifischen Hinweis gefragt wirst, den du nicht kennst (weil er entscheidend ist oder von Verd√§chtigen stammt), sage, dass dir dazu nichts bekannt ist oder es nicht Teil der polizeilichen Erkenntnisse ist. Deine bekannten Fakten sind: ${policeKnownFactsList}`;
            }
            // No accent logic needed anymore
            let finalInstructions = baseInstructions;

            const finalPrompt = `
Kontext: Dies ist ein Text-Detektivspiel. Der Spieler ist der Kommissar.
${plotSummary}
Du bist die Figur ${character.name} (${character.emoji}).
Deine Details im Spiel:
${characterInfo}
Deine Anweisungen f√ºr diese Antwort:
${finalInstructions}
Der Kommissar hat dich gerade gefragt: "${question}"
Antworte kurz und pr√§gnant (maximal 2-3 S√§tze) in der Ich-Form aus der Sicht von ${character.name}, auf Deutsch. Bleibe im Charakter und beachte deine Rolle, dein Wissen und deine Anweisungen. Gib keine Informationen preis, die du laut deiner Rolle nicht wissen kannst. Gib NUR die reine Antwort der Figur zur√ºck, ohne zus√§tzliche Erkl√§rungen wie "Als [Name] w√ºrde ich sagen: ...". Wenn die Frage unklar ist oder nichts mit dem Fall zu tun hat, weise h√∂flich darauf hin.
`;
            const chatGenerationConfig = { maxOutputTokens: 350, temperature: 0.8 };
            const response = await callGeminiAPI(finalPrompt, currentUserHistory, chatGenerationConfig);
            if (response !== null) {
                 addChatMessage(character.name, response, 'ai');
                 currentUserHistory.push({ role: 'model', parts: [{ text: response }] });
            } else {
                 addChatMessage('System', 'Ich konnte keine Antwort generieren.', 'ai');
            }
            SEND_BUTTON.disabled = false;
            const isSuspect = gameData.verdaechtige.some(v => v.id === selectedCharacterId);
            ACCUSE_BUTTON.disabled = !isSuspect;
        }

        // --- Accusation Logic with Custom Modal ---
        function showAccusationConfirmation(charId) {
             if (gameEnded || !gameData) return;
             const character = findCharacterById(charId);
             if (!character) return;
             CONFIRM_ACCUSATION_NAME.textContent = character.name;
             const confirmHandler = () => { hideAccusationConfirmation(); endGame(charId); };
             const cancelHandler = () => { hideAccusationConfirmation(); };
             CONFIRM_ACCUSATION_BUTTON.onclick = confirmHandler;
             CANCEL_ACCUSATION_BUTTON.onclick = cancelHandler;
             CONFIRM_ACCUSATION_MODAL.classList.remove('hidden');
             CONFIRM_ACCUSATION_MODAL.classList.add('flex');
        }
        function hideAccusationConfirmation() {
             CONFIRM_ACCUSATION_MODAL.classList.add('hidden');
             CONFIRM_ACCUSATION_MODAL.classList.remove('flex');
             CONFIRM_ACCUSATION_BUTTON.onclick = null;
             CANCEL_ACCUSATION_BUTTON.onclick = null;
        }

        function endGame(accusedCharId) {
            gameEnded = true;
            INTERACTION_AREA.classList.add('hidden');
            document.querySelectorAll('.character-button').forEach(btn => {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed');
                btn.classList.remove('hover:bg-gray-300', 'selected');
            });
            const accusedCharacter = findCharacterById(accusedCharId);
            const actualCulprit = findCharacterById(gameData.taeter_id);
            if (!accusedCharacter || !actualCulprit) {
                 console.error("Error during game evaluation: Character data missing.");
                 WIN_LOSE_MESSAGE.textContent = 'Ein Fehler ist bei der Spielauswertung aufgetreten.';
                 WIN_LOSE_MESSAGE.className = 'mt-6 p-4 rounded-md shadow text-center font-bold text-lg bg-gray-300 text-gray-800';
            } else if (accusedCharId === gameData.taeter_id) {
                WIN_LOSE_MESSAGE.textContent = `üéâ Herzlichen Gl√ºckwunsch! ${accusedCharacter.name} war tats√§chlich der T√§ter! ${gameData.loesung_erklaerung}`;
                WIN_LOSE_MESSAGE.className = 'mt-6 p-4 rounded-md shadow text-center font-bold text-lg bg-green-200 text-green-800';
            } else {
                WIN_LOSE_MESSAGE.textContent = `Leider falsch. ${accusedCharacter.name} war unschuldig. Der wahre T√§ter war ${actualCulprit.name} (${actualCulprit.emoji})! ${gameData.loesung_erklaerung}`;
                WIN_LOSE_MESSAGE.className = 'mt-6 p-4 rounded-md shadow text-center font-bold text-lg bg-red-200 text-red-800';
            }
             WIN_LOSE_MESSAGE.classList.remove('hidden');
        }

        // --- Initialization ---
        function displayProtocol() {
            if (!gameData) return;

            const allPoliceFacts = (gameData.neutrale_fakten || [])
                .filter(fact => /\/\s*Bekannt von:.*polizei/i.test(fact))
                .map(fact => fact.split('/ Bekannt von:')[0].trim());

            const shuffledPoliceFacts = allPoliceFacts.sort(() => 0.5 - Math.random());
            const maxFactsToShow = Math.min(5, shuffledPoliceFacts.length);
            const selectedPoliceFacts = shuffledPoliceFacts.slice(0, maxFactsToShow);

            const policeFactsHTML = selectedPoliceFacts.length > 0
                ? selectedPoliceFacts.map(fact => `<li>- ${fact}</li>`).join('')
                : '<li>Keine spezifischen Fakten bisher polizeibekannt.</li>';

            let protocolHTML = `<div class="protocol-section"><h3>Ermittlungsprotokoll (Auszug)</h3>`;
            protocolHTML += `<strong>Fall:</strong> ${gameData.fallbeschreibung}<br>`;
            protocolHTML += `<strong>Ort:</strong> ${gameData.tatort}<br>`;
            protocolHTML += `<strong>Zeit:</strong> ${gameData.zeitpunkt}<br>`;
            if (gameData.opfer) {
                 protocolHTML += `<strong>Opfer:</strong> ${gameData.opfer.name} (${gameData.opfer.beschreibung})<br>`;
            }
            protocolHTML += `</div><hr><div class="protocol-section"><strong>Verd√§chtige Personen:</strong><ul>`;
            gameData.verdaechtige.forEach(suspect => {
                 // Display name and reason for suspicion
                 protocolHTML += `<li><strong>${suspect.name}</strong> ${suspect.emoji}<br>`;
                 protocolHTML += `<small>&nbsp;&nbsp;Grund f√ºr Verdacht: ${suspect.verdachts_grund || 'Unbekannt'}</small></li>`;
            });
            protocolHTML += `</ul></div><hr><div class="protocol-section"><strong>Polizeibekannte Fakten (Auswahl):</strong><ul>${policeFactsHTML}</ul></div>`;
            protocolHTML += `<br><small>(Weitere Details, Alibis und entscheidende Hinweise m√ºssen durch Befragung ermittelt werden.)</small>`;

            PROTOCOL_DISPLAY.innerHTML = protocolHTML;
            PROTOCOL_DISPLAY.classList.remove('hidden');
        }


        async function initializeGame() {
             hideApiKeyError();
             apiKey = API_KEY_INPUT.value.trim();
             if (!apiKey) {
                 showApiKeyError('API Schl√ºssel darf nicht leer sein.');
                 return;
             }
             API_KEY_CONTENT.classList.add('hidden');
             MODAL_LOADING_INDICATOR.classList.remove('hidden');
             API_KEY_INPUT.disabled = true;
             SUBMIT_API_KEY_BUTTON.disabled = true;
             const plotSuccess = await generatePlot();
             MODAL_LOADING_INDICATOR.classList.add('hidden');
             if (plotSuccess && gameData) {
                 API_KEY_MODAL.style.display = 'none';
                 API_KEY_CONTENT.classList.remove('hidden');
                 API_KEY_INPUT.disabled = false;
                 SUBMIT_API_KEY_BUTTON.disabled = false;
                 BOSS_NAME_EL.textContent = gameData.boss.name + ':';
                 BOSS_EMOJI_EL.textContent = gameData.boss.emoji;
                 BRIEFING_TEXT_EL.textContent = gameData.boss.briefing;

                 displayProtocol();

                 displayCharacters();
                 GAME_CONTAINER.classList.remove('hidden');
                 gameEnded = false;
                 selectedCharacterId = null;
                 WIN_LOSE_MESSAGE.classList.add('hidden');
                 INTERACTION_AREA.classList.add('hidden');
             } else {
                 API_KEY_CONTENT.classList.remove('hidden');
                 API_KEY_INPUT.disabled = false;
                 SUBMIT_API_KEY_BUTTON.disabled = false;
                 if (API_KEY_ERROR.classList.contains('hidden')) {
                    showApiKeyError('Fall konnte nicht generiert werden. API-Antwort war unvollst√§ndig oder fehlerhaft. Versuche es erneut oder pr√ºfe die Konsole.');
                 }
                 API_KEY_MODAL.style.display = 'flex';
                 console.log("Initialization failed because plot generation was unsuccessful.");
             }
        }

        // --- Event Listeners ---
        SUBMIT_API_KEY_BUTTON.addEventListener('click', initializeGame);
        API_KEY_INPUT.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') { initializeGame(); }
        });
        SEND_BUTTON.addEventListener('click', handlePlayerInput);
        PLAYER_INPUT.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') { handlePlayerInput(); }
        });

    </script>

</body>
</html>
